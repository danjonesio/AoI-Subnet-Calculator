/**
 * Snyk Vulnerability Validation Tests
 * 
 * This test suite validates that the CWE-601 Open Redirect vulnerability
 * identified by Snyk has been properly fixed. It tests the specific
 * vulnerability scenario and ensures protection against various attack vectors.
 * 
 * Original Vulnerability: CWE-601 (Open Redirect)
 * Location: SubnetErrorBoundary component, line 343
 * Issue: Unsanitized use of window.location.pathname for navigation
 */

import {
  validateInternalURL,
  sanitizePath,
  navigateSecurely,
  reloadSecurely,
  getSecurityLogger,
  SUBNET_CALCULATOR_SECURITY_CONFIG,
  type SecurityEvent
} from '../url-security';

// Mock console methods to capture security logging
const mockConsoleError = jest.spyOn(console, 'error').mockImplementation();
const mockConsoleWarn = jest.spyOn(console, 'warn').mockImplementation();
const mockConsoleInfo = jest.spyOn(console, 'info').mockImplementation();

// Mock window.location for testing navigation
const mockLocation = {
  href: '',
  pathname: '/',
  reload: jest.fn()
};

// Store original location to restore later
const originalLocation = window.location;

// Mock location using delete and redefine approach
delete (window as any).location;
window.location = mockLocation as any;

describe('Snyk CWE-601 Vulnerability Validation', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockLocation.href = '';
    mockLocation.pathname = '/';
    mockLocation.reload.mockClear();
    
    // Clear security logger events
    getSecurityLogger().clearEvents();
    
    // Set development mode for enhanced logging
    process.env.NODE_ENV = 'development';
  });

  afterAll(() => {
    // Restore original location
    delete (window as any).location;
    window.location = originalLocation;
  });

  describe('Original vulnerability scenario validation', () => {
    it('should prevent direct use of window.location.pathname without validation', () => {
      // Simulate the original vulnerability scenario where window.location.pathname
      // could contain malicious content that gets used for navigation
      
      // Set up a malicious pathname (this would come from a crafted URL)
      mockLocation.pathname = 'javascript:alert("xss")';
      
      // The old vulnerable code would do: window.location.href = window.location.pathname
      // The new secure code should validate and sanitize this
      
      const validation = validateInternalURL(mockLocation.pathname);
      
      // Should be blocked
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/'); // Fallback to safe path
      expect(validation.reason).toMatch(/blocked pattern/i);
      
      // Should log security event
      const events = getSecurityLogger().getEvents();
      const blockedEvent = events.find(e => e.type === 'blocked_redirect');
      expect(blockedEvent).toBeDefined();
      expect(blockedEvent?.severity).toBe('high');
      expect(blockedEvent?.originalPath).toBe('javascript:alert("xss")');
    });

    it('should prevent protocol-relative URL attacks', () => {
      // Test the specific attack vector mentioned in CWE-601
      mockLocation.pathname = '//evil.com/malicious';
      
      const validation = validateInternalURL(mockLocation.pathname);
      
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/');
      expect(validation.reason).toMatch(/blocked pattern/i);
      
      // Verify security logging
      const events = getSecurityLogger().getEvents();
      const blockedEvent = events.find(e => e.type === 'blocked_redirect');
      expect(blockedEvent?.originalPath).toBe('//evil.com/malicious');
      expect(blockedEvent?.severity).toBe('high');
    });

    it('should prevent absolute URL redirects', () => {
      // Test absolute URL attacks
      const maliciousUrls = [
        'http://evil.com',
        'https://malicious.site',
        'HTTP://EVIL.COM', // Case insensitive
        'HTTPS://MALICIOUS.SITE'
      ];

      maliciousUrls.forEach(url => {
        mockLocation.pathname = url;
        
        const validation = validateInternalURL(mockLocation.pathname);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
      
      // Should have logged multiple security events
      const events = getSecurityLogger().getEvents();
      const blockedEvents = events.filter(e => e.type === 'blocked_redirect');
      expect(blockedEvents).toHaveLength(maliciousUrls.length);
    });

    it('should prevent JavaScript URL injection', () => {
      // Test JavaScript URL injection attacks
      const jsUrls = [
        'javascript:alert("xss")',
        'JAVASCRIPT:alert("xss")', // Case insensitive
        'javascript:window.location="http://evil.com"',
        'javascript:document.cookie="stolen"'
      ];

      jsUrls.forEach(url => {
        mockLocation.pathname = url;
        
        const validation = validateInternalURL(mockLocation.pathname);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
    });

    it('should prevent data URL attacks', () => {
      // Test data URL attacks
      const dataUrls = [
        'data:text/html,<script>alert("xss")</script>',
        'DATA:text/html,<script>alert("xss")</script>', // Case insensitive
        'data:text/html;base64,PHNjcmlwdD5hbGVydCgieHNzIik8L3NjcmlwdD4='
      ];

      dataUrls.forEach(url => {
        mockLocation.pathname = url;
        
        const validation = validateInternalURL(mockLocation.pathname);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
    });

    it('should prevent other protocol-based attacks', () => {
      // Test other protocol-based attacks
      const protocolUrls = [
        'vbscript:msgbox("xss")',
        'file:///etc/passwd',
        'ftp://malicious.com/file'
      ];

      protocolUrls.forEach(url => {
        mockLocation.pathname = url;
        
        const validation = validateInternalURL(mockLocation.pathname);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
    });
  });

  describe('Secure navigation implementation validation', () => {
    it('should use secure navigation instead of direct window.location assignment', () => {
      // Test that navigateSecurely properly validates before navigation
      const maliciousPath = 'javascript:alert("xss")';
      
      // This should not throw an error
      expect(() => navigateSecurely(maliciousPath)).not.toThrow();
      
      // Should log the blocked navigation attempt
      const events = getSecurityLogger().getEvents();
      const navEvent = events.find(e => e.type === 'navigation_attempt');
      expect(navEvent).toBeDefined();
      expect(navEvent?.originalPath).toBe(maliciousPath);
      expect(navEvent?.sanitizedPath).toBe('/');
      expect(navEvent?.reason).toMatch(/Navigation blocked/);
      
      // Verify that the validation logic would block the malicious path
      const validation = validateInternalURL(maliciousPath);
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/');
    });

    it('should use secure reload instead of direct window.location.reload', () => {
      // Secure reload should validate current path before reloading
      // In this test environment, window.location.pathname returns '/' (safe path)
      expect(() => reloadSecurely()).not.toThrow();
      
      // Should log the reload attempt
      const events = getSecurityLogger().getEvents();
      const reloadEvent = events.find(e => e.type === 'reload_attempt');
      expect(reloadEvent).toBeDefined();
      
      // The originalPath should be the current pathname (which is '/' in test environment)
      expect(reloadEvent?.originalPath).toBe('/');
      expect(reloadEvent?.reason).toMatch(/Safe page reload/);
      
      // Now test with a malicious path directly to verify the validation logic
      const maliciousPath = 'javascript:alert("xss")';
      const validation = validateInternalURL(maliciousPath);
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/');
      
      // If reloadSecurely were called with a malicious current pathname,
      // it would validate and redirect to safe path instead of reloading
      // This is the core security fix - validation before any navigation operation
    });

    it('should allow legitimate internal navigation', () => {
      // Test that legitimate paths still work
      const legitimatePaths = [
        '/',
        '/subnet-calculator',
        '/subnet-calculator/'
      ];

      legitimatePaths.forEach(path => {
        // Clear previous events
        getSecurityLogger().clearEvents();
        
        navigateSecurely(path);
        
        // Should log successful navigation
        const events = getSecurityLogger().getEvents();
        const navEvent = events.find(e => e.type === 'navigation_attempt');
        expect(navEvent).toBeDefined();
        expect(navEvent?.originalPath).toBe(path);
        expect(navEvent?.reason).toBe('Safe navigation');
        
        // Verify that the validation logic allows the legitimate path
        const validation = validateInternalURL(path);
        expect(validation.isValid).toBe(true);
      });
    });

    it('should allow legitimate page reloads', () => {
      // Set up legitimate current pathname
      mockLocation.pathname = '/subnet-calculator';
      
      reloadSecurely();
      
      // Should log successful reload
      const events = getSecurityLogger().getEvents();
      const reloadEvent = events.find(e => e.type === 'reload_attempt');
      expect(reloadEvent?.reason).toMatch(/Safe page reload/);
      
      // Verify that the validation logic allows the legitimate path
      const validation = validateInternalURL(mockLocation.pathname);
      expect(validation.isValid).toBe(true);
    });
  });

  describe('Path sanitization validation', () => {
    it('should sanitize path traversal attempts', () => {
      // Test path traversal attacks that could be used in combination with redirects
      const traversalPaths = [
        '/legitimate/../../../evil.com',
        '/subnet-calculator/../../../malicious',
        '/path/..../sensitive',
        '/../../../etc/passwd'
      ];

      traversalPaths.forEach(path => {
        const sanitized = sanitizePath(path);
        
        // Should remove path traversal attempts
        expect(sanitized).not.toContain('../');
        expect(sanitized).not.toContain('..../');
        
        // Should start with /
        expect(sanitized).toMatch(/^\/[^/]/);
      });
    });

    it('should remove dangerous characters', () => {
      // Test removal of null bytes and control characters
      const dangerousPaths = [
        '/path\x00\x01\x1f',
        '/path\x7f\x9f',
        '/path\r\n\t',
        '/path\0'
      ];

      dangerousPaths.forEach(path => {
        const sanitized = sanitizePath(path);
        
        // Should remove control characters
        expect(sanitized).toBe('/path');
      });
    });

    it('should handle path length limits', () => {
      // Test that extremely long paths are truncated
      const longPath = '/path' + 'a'.repeat(300);
      const sanitized = sanitizePath(longPath);
      
      expect(sanitized.length).toBeLessThanOrEqual(SUBNET_CALCULATOR_SECURITY_CONFIG.maxPathLength);
      expect(sanitized).toMatch(/^\/path/);
    });

    it('should normalize path separators', () => {
      // Test normalization of multiple slashes
      const unnormalizedPaths = [
        '//path///to////resource',
        '/path//to/resource/',
        '///path/to/resource///'
      ];

      unnormalizedPaths.forEach(path => {
        const sanitized = sanitizePath(path);
        
        // Should not contain multiple consecutive slashes
        expect(sanitized).not.toMatch(/\/\/+/);
        
        // Should start with single slash
        expect(sanitized).toMatch(/^\/[^/]/);
      });
    });
  });

  describe('Security configuration validation', () => {
    it('should have comprehensive blocked patterns', () => {
      const { blockedPatterns } = SUBNET_CALCULATOR_SECURITY_CONFIG;
      
      // Should block HTTP/HTTPS URLs
      expect(blockedPatterns.some(p => p.test('http://evil.com'))).toBe(true);
      expect(blockedPatterns.some(p => p.test('https://evil.com'))).toBe(true);
      
      // Should block protocol-relative URLs
      expect(blockedPatterns.some(p => p.test('//evil.com'))).toBe(true);
      
      // Should block JavaScript URLs
      expect(blockedPatterns.some(p => p.test('javascript:alert(1)'))).toBe(true);
      
      // Should block data URLs
      expect(blockedPatterns.some(p => p.test('data:text/html,<script>'))).toBe(true);
      
      // Should block other dangerous protocols
      expect(blockedPatterns.some(p => p.test('vbscript:msgbox(1)'))).toBe(true);
      expect(blockedPatterns.some(p => p.test('file:///etc/passwd'))).toBe(true);
      expect(blockedPatterns.some(p => p.test('ftp://evil.com'))).toBe(true);
    });

    it('should have appropriate allowed patterns', () => {
      const { allowedPatterns, allowedPaths } = SUBNET_CALCULATOR_SECURITY_CONFIG;
      
      // Should allow root path
      expect(allowedPaths.includes('/')).toBe(true);
      expect(allowedPatterns.some(p => p.test('/'))).toBe(true);
      
      // Should allow subnet calculator paths
      expect(allowedPaths.includes('/subnet-calculator')).toBe(true);
      expect(allowedPatterns.some(p => p.test('/subnet-calculator'))).toBe(true);
      expect(allowedPatterns.some(p => p.test('/subnet-calculator/'))).toBe(true);
    });

    it('should have reasonable security limits', () => {
      const config = SUBNET_CALCULATOR_SECURITY_CONFIG;
      
      // Should have reasonable path length limit
      expect(config.maxPathLength).toBeGreaterThan(0);
      expect(config.maxPathLength).toBeLessThan(1000); // Not too large
      
      // Should have safe fallback path
      expect(config.fallbackPath).toBe('/');
      
      // Should have blocked patterns array
      expect(Array.isArray(config.blockedPatterns)).toBe(true);
      expect(config.blockedPatterns.length).toBeGreaterThan(0);
    });
  });

  describe('Security logging and monitoring', () => {
    it('should log all security-relevant events', () => {
      // Perform various security-relevant actions
      validateInternalURL('http://evil.com'); // Should log blocked_redirect
      validateInternalURL('/path//'); // Should log sanitized_path
      validateInternalURL('/unauthorized'); // Should log validation_failure
      navigateSecurely('/subnet-calculator'); // Should log navigation_attempt
      reloadSecurely(); // Should log reload_attempt
      
      const events = getSecurityLogger().getEvents();
      
      // Should have logged multiple events
      expect(events.length).toBeGreaterThan(0);
      
      // Should have different event types
      const eventTypes = events.map(e => e.type);
      expect(eventTypes).toContain('blocked_redirect');
      expect(eventTypes).toContain('navigation_attempt');
      expect(eventTypes).toContain('reload_attempt');
    });

    it('should assign appropriate severity levels', () => {
      // High severity - blocked redirect
      validateInternalURL('http://evil.com');
      
      // Medium severity - validation failure
      validateInternalURL('/unauthorized-path');
      
      // Low severity - path sanitization
      validateInternalURL('/path//');
      
      const events = getSecurityLogger().getEvents();
      
      // Should have events with different severity levels
      const severities = events.map(e => e.severity);
      expect(severities).toContain('high');
      expect(severities).toContain('medium');
      expect(severities).toContain('low');
    });

    it('should include comprehensive event metadata', () => {
      validateInternalURL('http://evil.com');
      
      const events = getSecurityLogger().getEvents();
      const event = events[0];
      
      // Should include all required metadata
      expect(event).toHaveProperty('type');
      expect(event).toHaveProperty('originalPath');
      expect(event).toHaveProperty('sanitizedPath');
      expect(event).toHaveProperty('reason');
      expect(event).toHaveProperty('timestamp');
      expect(event).toHaveProperty('severity');
      expect(event).toHaveProperty('sessionId');
      
      // Timestamp should be valid ISO string
      expect(event.timestamp).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
      
      // Session ID should be valid format
      expect(event.sessionId).toMatch(/^session_\d+_[a-z0-9]+$/);
    });

    it('should handle production environment logging', () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = 'production';
      
      // Clear previous events
      getSecurityLogger().clearEvents();
      
      // Perform security-relevant action
      validateInternalURL('http://evil.com');
      
      // Should still log events in production
      const events = getSecurityLogger().getEvents();
      expect(events.length).toBeGreaterThan(0);
      
      // But should not log to console in production (except high severity)
      // This is tested in the main url-security tests
      
      process.env.NODE_ENV = originalEnv;
    });
  });

  describe('Edge cases and attack variations', () => {
    it('should handle URL encoding attacks', () => {
      // Test URL-encoded malicious payloads
      const encodedAttacks = [
        '%6A%61%76%61%73%63%72%69%70%74%3A%61%6C%65%72%74%28%31%29', // javascript:alert(1)
        '%68%74%74%70%3A%2F%2F%65%76%69%6C%2E%63%6F%6D', // http://evil.com
        '%2F%2F%65%76%69%6C%2E%63%6F%6D' // //evil.com
      ];

      encodedAttacks.forEach(encoded => {
        // Decode the URL (browsers would do this automatically)
        const decoded = decodeURIComponent(encoded);
        const validation = validateInternalURL(decoded);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
      });
    });

    it('should handle mixed case attacks', () => {
      // Test case variations that might bypass simple string matching
      const mixedCaseAttacks = [
        'JavaScript:alert(1)',
        'JAVASCRIPT:alert(1)',
        'Http://evil.com',
        'HTTPS://EVIL.COM',
        'Data:text/html,<script>',
        'VbScript:msgbox(1)'
      ];

      mixedCaseAttacks.forEach(attack => {
        const validation = validateInternalURL(attack);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
    });

    it('should handle whitespace and special character variations', () => {
      // Test attacks with whitespace and special characters
      const specialAttacks = [
        ' javascript:alert(1)',
        'javascript:alert(1) ',
        '\tjavascript:alert(1)',
        '\njavascript:alert(1)',
        'java\x00script:alert(1)',
        'java\tscript:alert(1)'
      ];

      specialAttacks.forEach(attack => {
        const sanitized = sanitizePath(attack);
        const validation = validateInternalURL(sanitized);
        
        // After sanitization, should either be safe or blocked
        if (!validation.isValid) {
          expect(validation.sanitizedPath).toBe('/');
        }
      });
    });

    it('should handle empty and null inputs', () => {
      // Test edge cases with empty/null inputs
      const edgeCases = [
        '',
        null,
        undefined,
        0,
        false,
        {}
      ];

      edgeCases.forEach(input => {
        const validation = validateInternalURL(input as any);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toBe('Empty or invalid URL');
      });
    });

    it('should handle extremely long malicious payloads', () => {
      // Test with very long malicious payloads
      const longMaliciousUrl = 'javascript:alert("' + 'x'.repeat(1000) + '")';
      
      const validation = validateInternalURL(longMaliciousUrl);
      
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/');
      expect(validation.reason).toMatch(/blocked pattern/i);
    });

    it('should handle nested attack attempts', () => {
      // Test nested or chained attack attempts
      const nestedAttacks = [
        'javascript:window.location="http://evil.com"',
        'javascript:document.location="//evil.com"',
        'data:text/html,<script>window.location="http://evil.com"</script>'
      ];

      nestedAttacks.forEach(attack => {
        const validation = validateInternalURL(attack);
        
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        expect(validation.reason).toMatch(/blocked pattern/i);
      });
    });
  });

  describe('Regression testing', () => {
    it('should maintain protection against original vulnerability', () => {
      // This test specifically validates that the original vulnerability
      // scenario cannot occur with the new implementation
      
      // Simulate the exact scenario from the Snyk report
      mockLocation.pathname = 'javascript:alert("CWE-601 Open Redirect")';
      
      // The old code would do: window.location.href = window.location.pathname
      // The new code should use secure navigation
      
      navigateSecurely(mockLocation.pathname);
      
      // Should log the blocked attempt
      const events = getSecurityLogger().getEvents();
      const blockedEvent = events.find(e => e.type === 'blocked_redirect');
      expect(blockedEvent).toBeDefined();
      expect(blockedEvent?.severity).toBe('high');
      
      // Verify that the validation logic blocks the malicious path
      const validation = validateInternalURL(mockLocation.pathname);
      expect(validation.isValid).toBe(false);
      expect(validation.sanitizedPath).toBe('/');
    });

    it('should prevent all variations of the original attack', () => {
      // Test all possible variations of the original attack vector
      const attackVariations = [
        'javascript:alert("xss")',
        'JAVASCRIPT:alert("xss")',
        'JavaScript:alert("xss")',
        'java\x00script:alert("xss")',
        'javascript:window.location="http://evil.com"',
        'javascript:document.cookie="stolen=true")',
        'javascript:eval("malicious code")'
      ];

      attackVariations.forEach(attack => {
        // Clear previous events
        getSecurityLogger().clearEvents();
        
        mockLocation.pathname = attack;
        
        // Use secure navigation (what the fixed code does)
        navigateSecurely(mockLocation.pathname);
        
        // Verify that the validation logic blocks each attack
        const validation = validateInternalURL(attack);
        expect(validation.isValid).toBe(false);
        expect(validation.sanitizedPath).toBe('/');
        
        // Should log the blocked attempt during validation
        // The blocked_redirect event is logged during validateInternalURL call inside navigateSecurely
        const events = getSecurityLogger().getEvents();
        
        // Some attacks may be sanitized first (e.g., null bytes removed) before being blocked
        // So we check for either blocked_redirect or validation_failure events
        const securityEvent = events.find(e => 
          e.type === 'blocked_redirect' || e.type === 'validation_failure'
        );
        expect(securityEvent).toBeDefined();
        expect(securityEvent?.originalPath).toBe(attack);
        expect(['high', 'medium']).toContain(securityEvent?.severity);
      });
    });

    it('should maintain legitimate functionality', () => {
      // Ensure that fixing the vulnerability doesn't break legitimate functionality
      const legitimateScenarios = [
        { pathname: '/', expected: '/' },
        { pathname: '/subnet-calculator', expected: '/subnet-calculator' },
        { pathname: '/subnet-calculator/', expected: '/subnet-calculator' }
      ];

      legitimateScenarios.forEach(({ pathname, expected }) => {
        // Clear previous events
        getSecurityLogger().clearEvents();
        
        mockLocation.pathname = pathname;
        
        // Use secure navigation
        navigateSecurely(mockLocation.pathname);
        
        // Verify that the validation logic allows legitimate paths
        const validation = validateInternalURL(pathname);
        expect(validation.isValid).toBe(true);
        expect(validation.sanitizedPath).toBe(expected);
        
        // Should log successful navigation
        const events = getSecurityLogger().getEvents();
        const navEvent = events.find(e => e.type === 'navigation_attempt');
        expect(navEvent).toBeDefined();
        expect(navEvent?.reason).toBe('Safe navigation');
      });
    });
  });
});