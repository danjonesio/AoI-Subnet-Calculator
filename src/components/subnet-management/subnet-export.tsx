"use client";

import React, { useState, useCallback, useMemo } from 'react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  Button
} from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Checkbox
} from '@/components/ui/checkbox';
import {
  Alert,
  AlertDescription
} from '@/components/ui/alert';
import {
  Download,
  Copy,
  FileText,
  Database,
  Code,
  Loader2,
  CheckCircle,
  AlertCircle
} from 'lucide-react';
import { SplitSubnet, ExportOptions, ExportResult, SubnetError } from '@/lib/types';

interface SubnetExportProps {
  subnets: SplitSubnet[];
  selectedSubnets: Set<string>;
  onExport?: (result: ExportResult) => void;
  onError?: (error: SubnetError) => void;
  availableFormats?: ExportOptions['format'][];
  className?: string;
}

export function SubnetExport({
  subnets,
  selectedSubnets,
  onExport,
  onError,
  availableFormats = ['text', 'csv', 'json'],
  className = ''
}: SubnetExportProps) {
  const [exportFormat, setExportFormat] = useState<ExportOptions['format']>('text');
  const [includeHeaders, setIncludeHeaders] = useState(true);
  const [includeMetadata, setIncludeMetadata] = useState(true);
  const [selectedOnly, setSelectedOnly] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [exportFeedback, setExportFeedback] = useState<{
    type: 'success' | 'error';
    message: string;
  } | null>(null);

  // Get subnets to export based on selection
  const subnetsToExport = useMemo(() => {
    if (selectedOnly && selectedSubnets.size > 0) {
      return subnets.filter(subnet => selectedSubnets.has(subnet.id));
    }
    return subnets;
  }, [subnets, selectedSubnets, selectedOnly]);

  // Format subnet data based on export format
  const formatSubnetData = useCallback((
    subnets: SplitSubnet[],
    options: ExportOptions
  ): string => {
    if (subnets.length === 0) {
      return '';
    }

    switch (options.format) {
      case 'text':
        return formatAsText(subnets, options);
      case 'csv':
        return formatAsCSV(subnets, options);
      case 'json':
        return formatAsJSON(subnets, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }, []);

  // Format as structured text
  const formatAsText = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const lines: string[] = [];

    if (options.includeHeaders) {
      lines.push('Subnet Export Report');
      lines.push('===================');
      lines.push('');
    }

    if (options.includeMetadata) {
      lines.push(`Export Date: ${new Date().toISOString()}`);
      lines.push(`Total Subnets: ${subnets.length}`);
      lines.push(`Export Format: ${options.format.toUpperCase()}`);
      lines.push(`Generated by: Art of Infra Subnet Calculator`);
      lines.push('');
    }

    subnets.forEach((subnet, index) => {
      lines.push(`Subnet ${index + 1}:`);
      lines.push(`  Network Address:    ${subnet.network}/${subnet.cidr}`);
      lines.push(`  Broadcast Address:  ${subnet.broadcast}`);
      lines.push(`  First Host IP:      ${subnet.firstHost}`);
      lines.push(`  Last Host IP:       ${subnet.lastHost}`);
      lines.push(`  Total Hosts:        ${subnet.totalHosts.toLocaleString()}`);
      lines.push(`  Usable Hosts:       ${subnet.usableHosts.toLocaleString()}`);

      // Add IPv6 specific information
      if (subnet.ipVersion === 'ipv6' && subnet.ipv6Info) {
        lines.push(`  Address Type:       ${subnet.ipv6Info.addressType}`);
        lines.push(`  Host Bits:          ${subnet.ipv6Info.hostBits}`);
        lines.push(`  Total Addresses:    ${subnet.ipv6Info.totalAddressesFormatted}`);
        lines.push(`  Usable Addresses:   ${subnet.ipv6Info.usableAddressesFormatted}`);
      }

      // Add cloud provider reserved IPs
      if (subnet.cloudReserved && subnet.cloudReserved.length > 0) {
        lines.push(`  Cloud Reserved IPs:`);
        subnet.cloudReserved.forEach(reservation => {
          lines.push(`    ${reservation.ip.padEnd(15)} - ${reservation.purpose}: ${reservation.description}`);
        });
      }

      if (index < subnets.length - 1) {
        lines.push('');
      }
    });

    return lines.join('\n');
  };

  // Format as CSV
  const formatAsCSV = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const lines: string[] = [];

    if (options.includeHeaders) {
      const headers = [
        'Network',
        'CIDR',
        'Broadcast',
        'First Host',
        'Last Host',
        'Total Hosts',
        'Usable Hosts',
        'IP Version'
      ];

      if (options.includeMetadata) {
        headers.push('Level', 'Parent ID', 'Has Cloud Reserved');
      }

      lines.push(headers.join(','));
    }

    subnets.forEach(subnet => {
      const row = [
        `"${subnet.network}"`,
        subnet.cidr.toString(),
        `"${subnet.broadcast}"`,
        `"${subnet.firstHost}"`,
        `"${subnet.lastHost}"`,
        subnet.totalHosts.toString(),
        subnet.usableHosts.toString(),
        `"${subnet.ipVersion}"`
      ];

      if (options.includeMetadata) {
        row.push(
          subnet.level.toString(),
          `"${subnet.parentId || ''}"`,
          (subnet.cloudReserved ? subnet.cloudReserved.length > 0 : false).toString()
        );
      }

      lines.push(row.join(','));
    });

    return lines.join('\n');
  };

  // Format as JSON
  const formatAsJSON = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const exportData: {
      subnets: Array<{
        id: string;
        network: string;
        cidr: number;
        broadcast: string;
        firstHost: string;
        lastHost: string;
        totalHosts: number;
        usableHosts: number;
        ipVersion: string;
        level?: number;
        parentId?: string;
        isSelected?: boolean;
        cloudReserved?: Array<{
          ip: string;
          purpose: string;
          description: string;
        }>;
        ipv6Info?: {
          addressType: string;
          hostBits: number;
          totalAddressesFormatted: string;
          usableAddressesFormatted: string;
        };
      }>;
      metadata?: {
        exportDate: string;
        totalSubnets: number;
        exportFormat: string;
        generatedBy: string;
        version: string;
      };
    } = {
      subnets: subnets.map(subnet => ({
        id: subnet.id,
        network: subnet.network,
        cidr: subnet.cidr,
        broadcast: subnet.broadcast,
        firstHost: subnet.firstHost,
        lastHost: subnet.lastHost,
        totalHosts: subnet.totalHosts,
        usableHosts: subnet.usableHosts,
        ipVersion: subnet.ipVersion,
        ...(options.includeMetadata && {
          level: subnet.level,
          parentId: subnet.parentId,
          isSelected: subnet.isSelected,
          cloudReserved: subnet.cloudReserved,
          ipv6Info: subnet.ipv6Info
        })
      }))
    };

    if (options.includeMetadata) {
      exportData.metadata = {
        exportDate: new Date().toISOString(),
        totalSubnets: subnets.length,
        exportFormat: options.format,
        generatedBy: 'Art of Infra Subnet Calculator',
        version: '1.0'
      };
    }

    return JSON.stringify(exportData, null, 2);
  };

  // Generate filename based on format and timestamp
  const generateFilename = useCallback((format: ExportOptions['format']): string => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const prefix = selectedOnly && selectedSubnets.size > 0 
      ? `selected-subnets-${selectedSubnets.size}` 
      : `all-subnets-${subnets.length}`;
    
    const extensions: Record<ExportOptions['format'], string> = {
      text: 'txt',
      csv: 'csv',
      json: 'json',
      yaml: 'yml'
    };

    return `${prefix}-${timestamp}.${extensions[format]}`;
  }, [selectedOnly, selectedSubnets.size, subnets.length]);

  // Get MIME type for format
  const getMimeType = (format: ExportOptions['format']): string => {
    const mimeTypes: Record<ExportOptions['format'], string> = {
      text: 'text/plain',
      csv: 'text/csv',
      json: 'application/json',
      yaml: 'text/yaml'
    };
    return mimeTypes[format];
  };

  // Handle copy to clipboard
  const handleCopyAll = useCallback(async () => {
    if (subnetsToExport.length === 0) {
      setExportFeedback({
        type: 'error',
        message: 'No subnets to copy'
      });
      setTimeout(() => setExportFeedback(null), 3000);
      return;
    }

    setIsExporting(true);

    try {
      const options: ExportOptions = {
        format: exportFormat,
        includeHeaders,
        includeMetadata,
        selectedOnly
      };

      const formattedData = formatSubnetData(subnetsToExport, options);

      if (!navigator.clipboard) {
        throw new Error('Clipboard API not available');
      }

      await navigator.clipboard.writeText(formattedData);

      setExportFeedback({
        type: 'success',
        message: `${subnetsToExport.length} subnet${subnetsToExport.length === 1 ? '' : 's'} copied to clipboard as ${exportFormat.toUpperCase()}`
      });

      // Call optional callback
      if (onExport) {
        const result: ExportResult = {
          data: formattedData,
          filename: generateFilename(exportFormat),
          mimeType: getMimeType(exportFormat),
          size: formattedData.length
        };
        onExport(result);
      }

    } catch (error) {
      console.error('Failed to copy subnets:', error);
      
      const subnetError: SubnetError = {
        type: 'export',
        message: error instanceof Error ? error.message : 'Failed to copy subnets to clipboard',
        timestamp: Date.now(),
        recoverable: true
      };

      setExportFeedback({
        type: 'error',
        message: subnetError.message
      });

      onError?.(subnetError);
    } finally {
      setIsExporting(false);
      setTimeout(() => setExportFeedback(null), 5000);
    }
  }, [subnetsToExport, exportFormat, includeHeaders, includeMetadata, selectedOnly, formatSubnetData, onExport, onError, generateFilename]);

  // Handle download file
  const handleDownload = useCallback(async () => {
    if (subnetsToExport.length === 0) {
      setExportFeedback({
        type: 'error',
        message: 'No subnets to download'
      });
      setTimeout(() => setExportFeedback(null), 3000);
      return;
    }

    setIsExporting(true);

    try {
      const options: ExportOptions = {
        format: exportFormat,
        includeHeaders,
        includeMetadata,
        selectedOnly
      };

      const formattedData = formatSubnetData(subnetsToExport, options);
      const filename = generateFilename(exportFormat);
      const mimeType = getMimeType(exportFormat);

      // Create and trigger download
      const blob = new Blob([formattedData], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setExportFeedback({
        type: 'success',
        message: `Downloaded ${filename} with ${subnetsToExport.length} subnet${subnetsToExport.length === 1 ? '' : 's'}`
      });

      // Call optional callback
      if (onExport) {
        const result: ExportResult = {
          data: formattedData,
          filename,
          mimeType,
          size: formattedData.length
        };
        onExport(result);
      }

    } catch (error) {
      console.error('Failed to download subnets:', error);
      
      const subnetError: SubnetError = {
        type: 'export',
        message: error instanceof Error ? error.message : 'Failed to download subnet file',
        timestamp: Date.now(),
        recoverable: true
      };

      setExportFeedback({
        type: 'error',
        message: subnetError.message
      });

      onError?.(subnetError);
    } finally {
      setIsExporting(false);
      setTimeout(() => setExportFeedback(null), 5000);
    }
  }, [subnetsToExport, exportFormat, includeHeaders, includeMetadata, selectedOnly, formatSubnetData, onExport, onError, generateFilename]);

  // Get format icon
  const getFormatIcon = (format: ExportOptions['format']) => {
    switch (format) {
      case 'text':
        return <FileText className="h-4 w-4" />;
      case 'csv':
        return <Database className="h-4 w-4" />;
      case 'json':
        return <Code className="h-4 w-4" />;
      default:
        return <FileText className="h-4 w-4" />;
    }
  };

  if (subnets.length === 0) {
    return (
      <Card className={`${className} rounded-lg shadow-md`}>
        <CardContent className="p-6 text-center py-8 text-muted-foreground">
          No subnets available for export
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className={`${className} rounded-lg shadow-md`}>
      {/* Live region for export feedback */}
      <div 
        aria-live="polite" 
        aria-atomic="true"
        className="sr-only"
        id="subnet-export-live-region"
      >
        {exportFeedback && exportFeedback.message}
        {isExporting && 'Export operation in progress...'}
      </div>

      <CardHeader className="p-6 pb-4">
        <CardTitle className="text-lg font-medium flex items-center gap-2">
          <Download className="h-5 w-5" aria-hidden="true" />
          <span id="subnet-export-title">Export Subnets</span>
        </CardTitle>
        <div id="subnet-export-description" className="sr-only">
          Export subnet information in various formats including text, CSV, and JSON. 
          Choose export options and scope before downloading or copying to clipboard.
          {subnets.length > 0 && ` ${subnets.length} subnet${subnets.length !== 1 ? 's' : ''} available for export.`}
          {selectedSubnets.size > 0 && ` ${selectedSubnets.size} subnet${selectedSubnets.size !== 1 ? 's' : ''} currently selected.`}
        </div>
      </CardHeader>
      <CardContent className="p-6 space-y-4">
        {/* Export feedback */}
        {exportFeedback && (
          <Alert className={exportFeedback.type === 'success' 
            ? 'border-green-200 bg-green-50 text-green-900 dark:border-green-800 dark:bg-green-900/20 dark:text-green-100'
            : 'border-red-200 bg-red-50 text-red-900 dark:border-red-800 dark:bg-red-900/20 dark:text-red-100'
          }>
            <div className="flex items-center gap-2">
              {exportFeedback.type === 'success' ? (
                <CheckCircle className="h-4 w-4" />
              ) : (
                <AlertCircle className="h-4 w-4" />
              )}
              <AlertDescription>
                {exportFeedback.message}
              </AlertDescription>
            </div>
          </Alert>
        )}

        {/* Export Format */}
        <div className="space-y-2">
          <label htmlFor="export-format" className="text-sm font-medium" id="export-format-label">
            Export Format
          </label>
          <Select 
            value={exportFormat} 
            onValueChange={(value) => setExportFormat(value as ExportOptions['format'])}
            aria-labelledby="export-format-label"
            aria-describedby="export-format-description"
          >
            <SelectTrigger id="export-format">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {availableFormats.map(format => (
                <SelectItem 
                  key={format} 
                  value={format}
                  aria-describedby={`format-${format}-description`}
                >
                  <div className="flex items-center gap-2">
                    {getFormatIcon(format)}
                    <span className="capitalize">{format}</span>
                    {format === 'text' && <span className="text-xs text-muted-foreground">(Human readable)</span>}
                    {format === 'csv' && <span className="text-xs text-muted-foreground">(Spreadsheet)</span>}
                    {format === 'json' && <span className="text-xs text-muted-foreground">(Structured data)</span>}
                  </div>
                  <span id={`format-${format}-description`} className="sr-only">
                    {format === 'text' && 'Plain text format suitable for human reading and documentation'}
                    {format === 'csv' && 'Comma-separated values format suitable for spreadsheet applications'}
                    {format === 'json' && 'JavaScript Object Notation format suitable for programmatic processing'}
                  </span>
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          <div id="export-format-description" className="sr-only">
            Choose the file format for exporting subnet data. Different formats are suitable for different use cases.
          </div>
        </div>

        {/* Export Scope */}
        <div className="space-y-2">
          <label className="text-sm font-medium" id="export-scope-label">Export Scope</label>
          <div 
            className="text-sm text-muted-foreground p-2 bg-muted rounded-md"
            aria-labelledby="export-scope-label"
            aria-describedby="export-scope-description"
          >
            {selectedOnly && selectedSubnets.size > 0 
              ? `Export selected subnets only (${selectedSubnets.size} subnet${selectedSubnets.size === 1 ? '' : 's'})`
              : `Export all subnets (${subnets.length} subnet${subnets.length === 1 ? '' : 's'})`
            }
          </div>
          <div id="export-scope-description" className="sr-only">
            Shows the number of subnets that will be included in the export based on current selection settings.
          </div>
        </div>

        {/* Export options checkboxes */}
        <fieldset className="space-y-3">
          <legend className="sr-only">Export Options</legend>
          <div className="flex items-center space-x-2">
            <Checkbox
              id="selectedOnly"
              checked={selectedOnly}
              onCheckedChange={(checked) => setSelectedOnly(checked === true)}
              disabled={selectedSubnets.size === 0}
              aria-describedby="selected-only-description"
            />
            <label 
              htmlFor="selectedOnly" 
              className={`text-sm ${selectedSubnets.size === 0 ? 'text-muted-foreground' : ''}`}
            >
              Export selected subnets only
              {selectedSubnets.size === 0 && ' (no subnets selected)'}
            </label>
            <div id="selected-only-description" className="sr-only">
              {selectedSubnets.size === 0 
                ? 'No subnets are currently selected. Select subnets first to enable this option.'
                : `Export only the ${selectedSubnets.size} currently selected subnet${selectedSubnets.size !== 1 ? 's' : ''} instead of all ${subnets.length} subnets.`
              }
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="includeHeaders"
              checked={includeHeaders}
              onCheckedChange={(checked) => setIncludeHeaders(checked === true)}
              aria-describedby="include-headers-description"
            />
            <label htmlFor="includeHeaders" className="text-sm">
              Include headers and titles
            </label>
            <div id="include-headers-description" className="sr-only">
              Include column headers and section titles in the exported data for better readability and structure.
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="includeMetadata"
              checked={includeMetadata}
              onCheckedChange={(checked) => setIncludeMetadata(checked === true)}
              aria-describedby="include-metadata-description"
            />
            <label htmlFor="includeMetadata" className="text-sm">
              Include metadata and additional information
            </label>
            <div id="include-metadata-description" className="sr-only">
              Include additional information such as export date, hierarchy levels, cloud provider details, and IPv6 specific data.
            </div>
          </div>
        </fieldset>

        {/* Export actions */}
        <div className="space-y-2 pt-4" role="group" aria-labelledby="export-actions-label">
          <div id="export-actions-label" className="sr-only">Export Actions</div>
          
          {/* Copy All to Clipboard Button - Full Width */}
          <Button
            onClick={handleCopyAll}
            disabled={isExporting || subnetsToExport.length === 0}
            className="w-full"
            aria-describedby="copy-button-description"
          >
            {isExporting ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" aria-hidden="true" />
            ) : (
              <Copy className="h-4 w-4 mr-2" aria-hidden="true" />
            )}
            <span>Copy All to Clipboard</span>
            {isExporting && <span className="sr-only">Export in progress...</span>}
          </Button>
          <div id="copy-button-description" className="sr-only">
            Copy {subnetsToExport.length} subnet{subnetsToExport.length !== 1 ? 's' : ''} to clipboard in {exportFormat.toUpperCase()} format. 
            {includeHeaders ? 'Headers will be included. ' : 'Headers will not be included. '}
            {includeMetadata ? 'Metadata will be included.' : 'Metadata will not be included.'}
          </div>

          {/* Download File Button - Full Width */}
          <Button
            onClick={handleDownload}
            disabled={isExporting || subnetsToExport.length === 0}
            variant="outline"
            className="w-full"
            aria-describedby="download-button-description"
          >
            {isExporting ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" aria-hidden="true" />
            ) : (
              <Download className="h-4 w-4 mr-2" aria-hidden="true" />
            )}
            <span>Download File</span>
            {isExporting && <span className="sr-only">Export in progress...</span>}
          </Button>
          <div id="download-button-description" className="sr-only">
            Download {subnetsToExport.length} subnet{subnetsToExport.length !== 1 ? 's' : ''} as a {exportFormat.toUpperCase()} file. 
            File will be named with timestamp and subnet count for easy identification.
          </div>
        </div>

        {/* Preview section */}
        {subnetsToExport.length > 0 && (
          <div className="mt-4 p-3 bg-muted rounded-md">
            <div className="text-sm font-medium mb-2">Export Preview:</div>
            <div className="text-xs text-muted-foreground space-y-1">
              <div>• Format: {exportFormat.toUpperCase()}</div>
              <div>• Subnets: {subnetsToExport.length}</div>
              <div>• Headers: {includeHeaders ? 'Yes' : 'No'}</div>
              <div>• Metadata: {includeMetadata ? 'Yes' : 'No'}</div>
              <div>• Estimated size: ~{Math.round(subnetsToExport.length * (exportFormat === 'json' ? 200 : exportFormat === 'csv' ? 100 : 150) / 1024)} KB</div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}