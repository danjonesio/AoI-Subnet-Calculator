"use client";

import React, { useState, useCallback, useMemo } from 'react';
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  Button
} from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Checkbox
} from '@/components/ui/checkbox';
import {
  Alert,
  AlertDescription
} from '@/components/ui/alert';
import {
  Download,
  Copy,
  FileText,
  Database,
  Code,
  Loader2,
  CheckCircle,
  AlertCircle
} from 'lucide-react';
import { SplitSubnet, ExportOptions, ExportResult, SubnetError } from '@/lib/types';

interface SubnetExportProps {
  subnets: SplitSubnet[];
  selectedSubnets: Set<string>;
  onExport?: (result: ExportResult) => void;
  onError?: (error: SubnetError) => void;
  availableFormats?: ExportOptions['format'][];
  className?: string;
}

export function SubnetExport({
  subnets,
  selectedSubnets,
  onExport,
  onError,
  availableFormats = ['text', 'csv', 'json'],
  className = ''
}: SubnetExportProps) {
  const [exportFormat, setExportFormat] = useState<ExportOptions['format']>('text');
  const [includeHeaders, setIncludeHeaders] = useState(true);
  const [includeMetadata, setIncludeMetadata] = useState(true);
  const [selectedOnly, setSelectedOnly] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [exportFeedback, setExportFeedback] = useState<{
    type: 'success' | 'error';
    message: string;
  } | null>(null);

  // Get subnets to export based on selection
  const subnetsToExport = useMemo(() => {
    if (selectedOnly && selectedSubnets.size > 0) {
      return subnets.filter(subnet => selectedSubnets.has(subnet.id));
    }
    return subnets;
  }, [subnets, selectedSubnets, selectedOnly]);

  // Format subnet data based on export format
  const formatSubnetData = useCallback((
    subnets: SplitSubnet[],
    options: ExportOptions
  ): string => {
    if (subnets.length === 0) {
      return '';
    }

    switch (options.format) {
      case 'text':
        return formatAsText(subnets, options);
      case 'csv':
        return formatAsCSV(subnets, options);
      case 'json':
        return formatAsJSON(subnets, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }, []);

  // Format as structured text
  const formatAsText = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const lines: string[] = [];

    if (options.includeHeaders) {
      lines.push('Subnet Export Report');
      lines.push('===================');
      lines.push('');
    }

    if (options.includeMetadata) {
      lines.push(`Export Date: ${new Date().toISOString()}`);
      lines.push(`Total Subnets: ${subnets.length}`);
      lines.push(`Export Format: ${options.format.toUpperCase()}`);
      lines.push(`Generated by: Art of Infra Subnet Calculator`);
      lines.push('');
    }

    subnets.forEach((subnet, index) => {
      lines.push(`Subnet ${index + 1}:`);
      lines.push(`  Network Address:    ${subnet.network}/${subnet.cidr}`);
      lines.push(`  Broadcast Address:  ${subnet.broadcast}`);
      lines.push(`  First Host IP:      ${subnet.firstHost}`);
      lines.push(`  Last Host IP:       ${subnet.lastHost}`);
      lines.push(`  Total Hosts:        ${subnet.totalHosts.toLocaleString()}`);
      lines.push(`  Usable Hosts:       ${subnet.usableHosts.toLocaleString()}`);

      // Add IPv6 specific information
      if (subnet.ipVersion === 'ipv6' && subnet.ipv6Info) {
        lines.push(`  Address Type:       ${subnet.ipv6Info.addressType}`);
        lines.push(`  Host Bits:          ${subnet.ipv6Info.hostBits}`);
        lines.push(`  Total Addresses:    ${subnet.ipv6Info.totalAddressesFormatted}`);
        lines.push(`  Usable Addresses:   ${subnet.ipv6Info.usableAddressesFormatted}`);
      }

      // Add cloud provider reserved IPs
      if (subnet.cloudReserved && subnet.cloudReserved.length > 0) {
        lines.push(`  Cloud Reserved IPs:`);
        subnet.cloudReserved.forEach(reservation => {
          lines.push(`    ${reservation.ip.padEnd(15)} - ${reservation.purpose}: ${reservation.description}`);
        });
      }

      if (index < subnets.length - 1) {
        lines.push('');
      }
    });

    return lines.join('\n');
  };

  // Format as CSV
  const formatAsCSV = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const lines: string[] = [];

    if (options.includeHeaders) {
      const headers = [
        'Network',
        'CIDR',
        'Broadcast',
        'First Host',
        'Last Host',
        'Total Hosts',
        'Usable Hosts',
        'IP Version'
      ];

      if (options.includeMetadata) {
        headers.push('Level', 'Parent ID', 'Has Cloud Reserved');
      }

      lines.push(headers.join(','));
    }

    subnets.forEach(subnet => {
      const row = [
        `"${subnet.network}"`,
        subnet.cidr.toString(),
        `"${subnet.broadcast}"`,
        `"${subnet.firstHost}"`,
        `"${subnet.lastHost}"`,
        subnet.totalHosts.toString(),
        subnet.usableHosts.toString(),
        `"${subnet.ipVersion}"`
      ];

      if (options.includeMetadata) {
        row.push(
          subnet.level.toString(),
          `"${subnet.parentId || ''}"`,
          (subnet.cloudReserved ? subnet.cloudReserved.length > 0 : false).toString()
        );
      }

      lines.push(row.join(','));
    });

    return lines.join('\n');
  };

  // Format as JSON
  const formatAsJSON = (subnets: SplitSubnet[], options: ExportOptions): string => {
    const exportData: {
      subnets: Array<{
        id: string;
        network: string;
        cidr: number;
        broadcast: string;
        firstHost: string;
        lastHost: string;
        totalHosts: number;
        usableHosts: number;
        ipVersion: string;
        level?: number;
        parentId?: string;
        isSelected?: boolean;
        cloudReserved?: Array<{
          ip: string;
          purpose: string;
          description: string;
        }>;
        ipv6Info?: {
          addressType: string;
          hostBits: number;
          totalAddressesFormatted: string;
          usableAddressesFormatted: string;
        };
      }>;
      metadata?: {
        exportDate: string;
        totalSubnets: number;
        exportFormat: string;
        generatedBy: string;
        version: string;
      };
    } = {
      subnets: subnets.map(subnet => ({
        id: subnet.id,
        network: subnet.network,
        cidr: subnet.cidr,
        broadcast: subnet.broadcast,
        firstHost: subnet.firstHost,
        lastHost: subnet.lastHost,
        totalHosts: subnet.totalHosts,
        usableHosts: subnet.usableHosts,
        ipVersion: subnet.ipVersion,
        ...(options.includeMetadata && {
          level: subnet.level,
          parentId: subnet.parentId,
          isSelected: subnet.isSelected,
          cloudReserved: subnet.cloudReserved,
          ipv6Info: subnet.ipv6Info
        })
      }))
    };

    if (options.includeMetadata) {
      exportData.metadata = {
        exportDate: new Date().toISOString(),
        totalSubnets: subnets.length,
        exportFormat: options.format,
        generatedBy: 'Art of Infra Subnet Calculator',
        version: '1.0'
      };
    }

    return JSON.stringify(exportData, null, 2);
  };

  // Generate filename based on format and timestamp
  const generateFilename = useCallback((format: ExportOptions['format']): string => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const prefix = selectedOnly && selectedSubnets.size > 0 
      ? `selected-subnets-${selectedSubnets.size}` 
      : `all-subnets-${subnets.length}`;
    
    const extensions: Record<ExportOptions['format'], string> = {
      text: 'txt',
      csv: 'csv',
      json: 'json',
      yaml: 'yml'
    };

    return `${prefix}-${timestamp}.${extensions[format]}`;
  }, [selectedOnly, selectedSubnets.size, subnets.length]);

  // Get MIME type for format
  const getMimeType = (format: ExportOptions['format']): string => {
    const mimeTypes: Record<ExportOptions['format'], string> = {
      text: 'text/plain',
      csv: 'text/csv',
      json: 'application/json',
      yaml: 'text/yaml'
    };
    return mimeTypes[format];
  };

  // Handle copy to clipboard
  const handleCopyAll = useCallback(async () => {
    if (subnetsToExport.length === 0) {
      setExportFeedback({
        type: 'error',
        message: 'No subnets to copy'
      });
      setTimeout(() => setExportFeedback(null), 3000);
      return;
    }

    setIsExporting(true);

    try {
      const options: ExportOptions = {
        format: exportFormat,
        includeHeaders,
        includeMetadata,
        selectedOnly
      };

      const formattedData = formatSubnetData(subnetsToExport, options);

      if (!navigator.clipboard) {
        throw new Error('Clipboard API not available');
      }

      await navigator.clipboard.writeText(formattedData);

      setExportFeedback({
        type: 'success',
        message: `${subnetsToExport.length} subnet${subnetsToExport.length === 1 ? '' : 's'} copied to clipboard as ${exportFormat.toUpperCase()}`
      });

      // Call optional callback
      if (onExport) {
        const result: ExportResult = {
          data: formattedData,
          filename: generateFilename(exportFormat),
          mimeType: getMimeType(exportFormat),
          size: formattedData.length
        };
        onExport(result);
      }

    } catch (error) {
      console.error('Failed to copy subnets:', error);
      
      const subnetError: SubnetError = {
        type: 'export',
        message: error instanceof Error ? error.message : 'Failed to copy subnets to clipboard',
        timestamp: Date.now(),
        recoverable: true
      };

      setExportFeedback({
        type: 'error',
        message: subnetError.message
      });

      onError?.(subnetError);
    } finally {
      setIsExporting(false);
      setTimeout(() => setExportFeedback(null), 5000);
    }
  }, [subnetsToExport, exportFormat, includeHeaders, includeMetadata, selectedOnly, formatSubnetData, onExport, onError, generateFilename]);

  // Handle download file
  const handleDownload = useCallback(async () => {
    if (subnetsToExport.length === 0) {
      setExportFeedback({
        type: 'error',
        message: 'No subnets to download'
      });
      setTimeout(() => setExportFeedback(null), 3000);
      return;
    }

    setIsExporting(true);

    try {
      const options: ExportOptions = {
        format: exportFormat,
        includeHeaders,
        includeMetadata,
        selectedOnly
      };

      const formattedData = formatSubnetData(subnetsToExport, options);
      const filename = generateFilename(exportFormat);
      const mimeType = getMimeType(exportFormat);

      // Create and trigger download
      const blob = new Blob([formattedData], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);

      setExportFeedback({
        type: 'success',
        message: `Downloaded ${filename} with ${subnetsToExport.length} subnet${subnetsToExport.length === 1 ? '' : 's'}`
      });

      // Call optional callback
      if (onExport) {
        const result: ExportResult = {
          data: formattedData,
          filename,
          mimeType,
          size: formattedData.length
        };
        onExport(result);
      }

    } catch (error) {
      console.error('Failed to download subnets:', error);
      
      const subnetError: SubnetError = {
        type: 'export',
        message: error instanceof Error ? error.message : 'Failed to download subnet file',
        timestamp: Date.now(),
        recoverable: true
      };

      setExportFeedback({
        type: 'error',
        message: subnetError.message
      });

      onError?.(subnetError);
    } finally {
      setIsExporting(false);
      setTimeout(() => setExportFeedback(null), 5000);
    }
  }, [subnetsToExport, exportFormat, includeHeaders, includeMetadata, selectedOnly, formatSubnetData, onExport, onError, generateFilename]);

  // Get format icon
  const getFormatIcon = (format: ExportOptions['format']) => {
    switch (format) {
      case 'text':
        return <FileText className="h-4 w-4" />;
      case 'csv':
        return <Database className="h-4 w-4" />;
      case 'json':
        return <Code className="h-4 w-4" />;
      default:
        return <FileText className="h-4 w-4" />;
    }
  };

  if (subnets.length === 0) {
    return (
      <Card className={className}>
        <CardContent className="text-center py-8 text-muted-foreground">
          No subnets available for export
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className={className}>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Download className="h-5 w-5" />
          Export Subnets
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Export feedback */}
        {exportFeedback && (
          <Alert className={exportFeedback.type === 'success' 
            ? 'border-green-200 bg-green-50 text-green-900 dark:border-green-800 dark:bg-green-900/20 dark:text-green-100'
            : 'border-red-200 bg-red-50 text-red-900 dark:border-red-800 dark:bg-red-900/20 dark:text-red-100'
          }>
            <div className="flex items-center gap-2">
              {exportFeedback.type === 'success' ? (
                <CheckCircle className="h-4 w-4" />
              ) : (
                <AlertCircle className="h-4 w-4" />
              )}
              <AlertDescription>
                {exportFeedback.message}
              </AlertDescription>
            </div>
          </Alert>
        )}

        {/* Export options */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Format selection */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Export Format</label>
            <Select value={exportFormat} onValueChange={(value) => setExportFormat(value as ExportOptions['format'])}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {availableFormats.map(format => (
                  <SelectItem key={format} value={format}>
                    <div className="flex items-center gap-2">
                      {getFormatIcon(format)}
                      <span className="capitalize">{format}</span>
                      {format === 'text' && <span className="text-xs text-muted-foreground">(Human readable)</span>}
                      {format === 'csv' && <span className="text-xs text-muted-foreground">(Spreadsheet)</span>}
                      {format === 'json' && <span className="text-xs text-muted-foreground">(Structured data)</span>}
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          {/* Export scope */}
          <div className="space-y-2">
            <label className="text-sm font-medium">Export Scope</label>
            <div className="text-sm text-muted-foreground">
              {selectedOnly && selectedSubnets.size > 0 
                ? `${selectedSubnets.size} selected subnet${selectedSubnets.size === 1 ? '' : 's'}`
                : `All ${subnets.length} subnet${subnets.length === 1 ? '' : 's'}`
              }
            </div>
          </div>
        </div>

        {/* Export options checkboxes */}
        <div className="space-y-3">
          <div className="flex items-center space-x-2">
            <Checkbox
              id="selectedOnly"
              checked={selectedOnly}
              onCheckedChange={(checked) => setSelectedOnly(checked === true)}
              disabled={selectedSubnets.size === 0}
            />
            <label 
              htmlFor="selectedOnly" 
              className={`text-sm ${selectedSubnets.size === 0 ? 'text-muted-foreground' : ''}`}
            >
              Export selected subnets only
              {selectedSubnets.size === 0 && ' (no subnets selected)'}
            </label>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="includeHeaders"
              checked={includeHeaders}
              onCheckedChange={(checked) => setIncludeHeaders(checked === true)}
            />
            <label htmlFor="includeHeaders" className="text-sm">
              Include headers and titles
            </label>
          </div>

          <div className="flex items-center space-x-2">
            <Checkbox
              id="includeMetadata"
              checked={includeMetadata}
              onCheckedChange={(checked) => setIncludeMetadata(checked === true)}
            />
            <label htmlFor="includeMetadata" className="text-sm">
              Include metadata and additional information
            </label>
          </div>
        </div>

        {/* Export actions */}
        <div className="flex flex-col sm:flex-row gap-2 pt-4">
          <Button
            onClick={handleCopyAll}
            disabled={isExporting || subnetsToExport.length === 0}
            className="flex-1"
          >
            {isExporting ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <Copy className="h-4 w-4 mr-2" />
            )}
            Copy All to Clipboard
          </Button>

          <Button
            onClick={handleDownload}
            disabled={isExporting || subnetsToExport.length === 0}
            variant="outline"
            className="flex-1"
          >
            {isExporting ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <Download className="h-4 w-4 mr-2" />
            )}
            Download File
          </Button>
        </div>

        {/* Preview section */}
        {subnetsToExport.length > 0 && (
          <div className="mt-4 p-3 bg-muted rounded-md">
            <div className="text-sm font-medium mb-2">Export Preview:</div>
            <div className="text-xs text-muted-foreground space-y-1">
              <div>• Format: {exportFormat.toUpperCase()}</div>
              <div>• Subnets: {subnetsToExport.length}</div>
              <div>• Headers: {includeHeaders ? 'Yes' : 'No'}</div>
              <div>• Metadata: {includeMetadata ? 'Yes' : 'No'}</div>
              <div>• Estimated size: ~{Math.round(subnetsToExport.length * (exportFormat === 'json' ? 200 : exportFormat === 'csv' ? 100 : 150) / 1024)} KB</div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}